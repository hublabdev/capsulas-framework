# AI Assistant Guide for Capsulas

**Purpose**: This document is designed for AI assistants (like Claude, GPT-4, etc.) to quickly understand code generated by Capsulas and help users deploy it to various platforms.

## Quick Context Recognition

When you encounter code generated by Capsulas, look for these markers:

```typescript
// Generated by Capsulas Framework
// Version: 0.1.0
// Flow: [flow-name]
// Nodes: [count]
// Connections: [count]
```

## What You're Looking At

### File Structure You'll See

```
generated-project/
├── flow.json              # Visual flow definition
├── generated-app.ts       # Main application code
├── package.json           # Dependencies
├── .env.example          # Required environment variables
└── README.md             # User-facing documentation
```

### Core Patterns to Recognize

#### 1. Service Initialization Pattern
```typescript
// Pattern: Capsulas always initializes services first
const authService = createAuthService({ /* config */ });
const dbService = createDatabaseService({ /* config */ });
const aiService = createAIService({ /* config */ });
```

**What this means**: Each service is a capsule instance. They're independent and configured separately.

#### 2. Topological Execution Pattern
```typescript
// Pattern: Nodes execute in dependency order
// Step 1, Step 2, Step 3... comments indicate execution order

async function executeFlow() {
  // ===== STEP 1: Auth =====
  const result_node_1 = await authService.login(/*...*/);

  // ===== STEP 2: Database ===== (depends on Step 1)
  const input_node_2 = {
    user: result_node_1?.user  // Data flows from previous step
  };
  const result_node_2 = await dbService.query(/*...*/);
}
```

**What this means**: Each step depends on previous steps. The flow is already ordered correctly.

#### 3. Port Connection Pattern
```typescript
// Pattern: Input variables reference previous outputs
const input_node_X = {
  portName: result_node_Y?.outputPort
};
```

**What this means**: Data flows through connections. `result_node_Y` is the output from a previous node.

## Helping Users Deploy

### Quick Platform Detection

Ask the user ONE question:
> "Where would you like to deploy this? (Vercel / Railway / AWS / Replit / Heroku / Other)"

Then follow the appropriate guide below.

### Platform-Specific Guides

#### Vercel (Next.js API Routes)

**What to do**:
1. Create `pages/api/` directory
2. Convert main flow into API route
3. Add `vercel.json` configuration

**Key changes needed**:
```typescript
// Transform this:
async function executeFlow() { /*...*/ }

// Into this:
export default async function handler(req, res) {
  const result = await executeFlow();
  res.json(result);
}
```

**Files to create**:
- `pages/api/flow.ts` - Main endpoint
- `vercel.json` - Configuration
- `.env.local` - Environment variables

**Dependencies to add**: `next`, `@vercel/node`

---

#### Railway (Node.js Server)

**What to do**:
1. Add Express server wrapper
2. Configure PORT from environment
3. Add health check endpoint

**Key changes needed**:
```typescript
// Add Express wrapper
import express from 'express';
const app = express();

app.post('/execute', async (req, res) => {
  const result = await executeFlow();
  res.json(result);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT);
```

**Files to create**:
- `server.ts` - Express server
- `railway.json` - Configuration
- `Procfile` - Process definition

**Dependencies to add**: `express`, `@types/express`

---

#### AWS Lambda

**What to do**:
1. Wrap in Lambda handler
2. Configure layers for dependencies
3. Set up environment variables in AWS Console

**Key changes needed**:
```typescript
// Transform into Lambda handler
export const handler = async (event, context) => {
  const result = await executeFlow();
  return {
    statusCode: 200,
    body: JSON.stringify(result)
  };
};
```

**Files to create**:
- `lambda.ts` - Handler
- `serverless.yml` - Serverless config (optional)
- `template.yaml` - SAM template

**Build process**: `tsc && zip -r function.zip dist/ node_modules/`

---

#### Replit

**What to do**:
1. Create `.replit` configuration
2. Add Express server
3. Configure run command

**Key changes needed**:
```typescript
// Simple Express server
app.get('/', (req, res) => res.send('Flow API Running'));
app.post('/run', async (req, res) => {
  const result = await executeFlow();
  res.json(result);
});
```

**Files to create**:
- `.replit` - Replit configuration
- `replit.nix` - Nix packages
- `server.ts` - Express server

---

#### Heroku

**What to do**:
1. Add Express server
2. Create Procfile
3. Configure buildpacks

**Key changes needed**: Same as Railway

**Files to create**:
- `Procfile`: `web: node dist/server.js`
- `app.json` - App manifest

---

#### Docker (Any Platform)

**What to do**:
1. Create multi-stage Dockerfile
2. Add docker-compose for local testing
3. Document environment variables

**Files to create**:

`Dockerfile`:
```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
EXPOSE 3000
CMD ["node", "dist/server.js"]
```

`docker-compose.yml`:
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    env_file:
      - .env
```

## Understanding Capsule Types

When you see service names, here's what they do:

| Service Name | Purpose | Common Env Vars |
|--------------|---------|-----------------|
| `authService` | Authentication | `JWT_SECRET`, `OAUTH_CLIENT_ID` |
| `databaseService` | Database queries | `DATABASE_URL` |
| `aiService` | AI completions | `OPENAI_API_KEY`, `ANTHROPIC_API_KEY` |
| `emailService` | Send emails | `SENDGRID_API_KEY`, `SMTP_HOST` |
| `queueService` | Background jobs | `REDIS_URL` |
| `cacheService` | Caching | `REDIS_URL` |
| `storageService` | File storage | `AWS_ACCESS_KEY_ID`, `S3_BUCKET` |
| `webhookService` | HTTP webhooks | None (uses URLs) |
| `stripeService` | Payments | `STRIPE_SECRET_KEY` |

## Common Tasks & Solutions

### Task: "Help me deploy this to [platform]"

**Steps**:
1. Identify the platform from the list above
2. Check which capsules are used (look for service names)
3. List required environment variables
4. Create platform-specific files
5. Provide deployment command

**Example response**:
```
I see you're using:
- Auth JWT capsule
- Database capsule
- AI Chat capsule

For Vercel deployment, you'll need:

1. Environment variables in Vercel dashboard:
   - DATABASE_URL
   - JWT_SECRET
   - OPENAI_API_KEY

2. Files I'll create:
   - pages/api/flow.ts
   - vercel.json
   - .env.local (template)

3. Deploy command:
   vercel --prod
```

### Task: "The code doesn't work"

**Diagnostic checklist**:
1. Are environment variables set? Check `.env.example`
2. Are dependencies installed? Check `package.json`
3. Are services initialized? Look for `create*Service()` calls
4. Is data flowing correctly? Check `input_node_X` variables
5. Are there type mismatches? Check port connections

**Common fixes**:
- Missing env vars → Create `.env` from `.env.example`
- Wrong types → Check if ports are compatible (see flow.json)
- Undefined variables → Check if previous step succeeded

### Task: "Add error handling"

**Pattern to apply**:
```typescript
// Wrap each step
try {
  const result_node_1 = await authService.login(/*...*/);
} catch (error) {
  console.error('Step 1 (Auth) failed:', error);
  // Decide: throw, return error, or continue
  throw new Error(`Authentication failed: ${error.message}`);
}
```

### Task: "Add logging"

**Pattern to apply**:
```typescript
// Before each step
console.log('Starting Step 1: Auth');
console.log('Input:', input_node_1);

const result_node_1 = await authService.login(/*...*/);

console.log('Step 1 complete:', result_node_1);
```

### Task: "Make it production-ready"

**Checklist to implement**:
- [ ] Add error handling (try/catch)
- [ ] Add logging (console.log or Winston)
- [ ] Add input validation (Zod, Joi)
- [ ] Add rate limiting (if API)
- [ ] Add health check endpoint
- [ ] Add graceful shutdown
- [ ] Add monitoring (Sentry, DataDog)
- [ ] Add tests (Jest, Vitest)
- [ ] Add TypeScript strict mode
- [ ] Add CI/CD pipeline

## Reading the Flow Definition

The `flow.json` file contains the visual representation:

```json
{
  "nodes": [
    {
      "id": "node-1",
      "capsule": { "id": "auth-jwt", "name": "JWT Auth" },
      "position": { "x": 100, "y": 100 },
      "config": { "secret": "..." }
    }
  ],
  "connections": [
    {
      "id": "conn-1",
      "fromNode": "node-1",
      "fromPort": "token",
      "toNode": "node-2",
      "toPort": "auth"
    }
  ]
}
```

**What this tells you**:
- Which capsules are used
- How data flows (connections)
- User configuration (config objects)
- Visual layout (for debugging)

## Environment Variable Patterns

Capsulas uses consistent naming:

```bash
# Database
DATABASE_URL=postgresql://user:pass@host:5432/db
MONGODB_URI=mongodb://host:27017/db

# Auth
JWT_SECRET=your-secret-key-min-32-chars
OAUTH_CLIENT_ID=...
OAUTH_CLIENT_SECRET=...
OAUTH_REDIRECT_URI=http://localhost:3000/callback

# AI
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
AI_MODEL=gpt-4  # or claude-3-opus-20240229

# Email
SENDGRID_API_KEY=SG...
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=...
SMTP_PASS=...

# Storage
AWS_ACCESS_KEY_ID=...
AWS_SECRET_ACCESS_KEY=...
S3_BUCKET=my-bucket
S3_REGION=us-east-1

# Payments
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...

# Queue/Cache
REDIS_URL=redis://localhost:6379
```

## TypeScript Types Reference

Capsulas uses these standard types:

```typescript
// Common interfaces you'll see
interface User {
  id: string;
  email: string;
  name?: string;
}

interface AuthToken {
  token: string;
  expiresAt: string;
}

interface DatabaseResult {
  rows: any[];
  count: number;
}

interface AIResponse {
  content: string;
  model: string;
  usage: { tokens: number };
}

interface EmailResult {
  messageId: string;
  status: 'sent' | 'failed';
}

interface JobResult {
  jobId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
}
```

## Optimization Patterns

### Pattern 1: Parallel Execution

If you see independent steps, suggest parallelization:

```typescript
// Sequential (slow)
const result1 = await service1.execute();
const result2 = await service2.execute();

// Parallel (fast)
const [result1, result2] = await Promise.all([
  service1.execute(),
  service2.execute()
]);
```

### Pattern 2: Caching

If you see repeated calls, suggest caching:

```typescript
// Add cache layer
const cacheKey = `user:${userId}`;
let user = await cache.get(cacheKey);

if (!user) {
  user = await db.getUser(userId);
  await cache.set(cacheKey, user, 3600); // 1 hour
}
```

### Pattern 3: Retry Logic

For external API calls, suggest retries:

```typescript
async function withRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(r => setTimeout(r, 1000 * (i + 1)));
    }
  }
}

const result = await withRetry(() => aiService.chat(prompt));
```

## Testing Generated Code

### Unit Test Pattern

```typescript
import { describe, it, expect } from 'vitest';

describe('Flow Execution', () => {
  it('should execute successfully with valid inputs', async () => {
    const result = await executeFlow();
    expect(result).toBeDefined();
  });

  it('should handle missing environment variables', async () => {
    delete process.env.DATABASE_URL;
    await expect(executeFlow()).rejects.toThrow();
  });
});
```

### Integration Test Pattern

```typescript
describe('End-to-End Flow', () => {
  beforeAll(async () => {
    // Setup test database, mock APIs
  });

  it('should complete full flow', async () => {
    const result = await executeFlow();
    expect(result.success).toBe(true);
  });

  afterAll(async () => {
    // Cleanup
  });
});
```

## When Things Go Wrong

### Error: "Cannot find module"
**Cause**: Missing dependency
**Fix**: `npm install [missing-package]`

### Error: "Unexpected token"
**Cause**: Not compiled or wrong module type
**Fix**: Run `tsc` or check tsconfig.json

### Error: "Cannot read property of undefined"
**Cause**: Previous step failed, data didn't flow
**Fix**: Add null checks or fix previous step

### Error: "Authentication failed"
**Cause**: Wrong environment variable
**Fix**: Check `.env` matches `.env.example`

### Error: "CORS error"
**Cause**: Missing CORS headers
**Fix**: Add CORS middleware (see platform guides)

## Summary Checklist for AI Assistants

When helping with Capsulas code:

- [ ] Identify the platform (ask if unclear)
- [ ] List all capsules used (check service names)
- [ ] List required environment variables
- [ ] Check if code is already compiled (dist/ folder)
- [ ] Suggest platform-specific modifications
- [ ] Provide complete file templates
- [ ] Include deployment commands
- [ ] Mention common pitfalls for that platform
- [ ] Suggest production improvements if appropriate

## Quick Command Reference

```bash
# Development
npm install          # Install dependencies
npm run build        # Compile TypeScript
npm run dev          # Run with watch mode
npm test             # Run tests

# Deployment
vercel --prod        # Deploy to Vercel
railway up           # Deploy to Railway
heroku create        # Create Heroku app
docker build -t app  # Build Docker image

# Debugging
npm run type-check   # Check TypeScript errors
npm run lint         # Check code style
node --inspect       # Debug with inspector
```

---

**Remember**: Capsulas generates working code. Your role is to adapt it to the user's deployment target and production needs. Always prioritize clarity and completeness in your responses.
