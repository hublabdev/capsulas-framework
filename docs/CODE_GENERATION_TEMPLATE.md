# Code Generation Template

This document defines the standard template for code generated by Capsulas. This template is optimized for AI assistants to understand and modify.

## Template Structure

Every generated file follows this pattern:

```typescript
/**
 * GENERATED BY CAPSULAS FRAMEWORK
 *
 * @version 0.1.0
 * @generated {timestamp}
 * @flow {flowName}
 * @nodes {nodeCount}
 * @connections {connectionCount}
 *
 * AI ASSISTANT HINTS:
 * - This code was generated from a visual flow
 * - Each section is clearly marked with comments
 * - Services are initialized in dependency order
 * - Execution follows topological sort
 * - Data flows through result_node_X variables
 * - See flow.json for visual representation
 *
 * QUICK DEPLOYMENT:
 * 1. Install dependencies: npm install
 * 2. Set environment variables: cp .env.example .env
 * 3. Build: npm run build
 * 4. Run: node dist/generated-app.js
 *
 * PLATFORM-SPECIFIC:
 * - Vercel: See AI_ASSISTANT_GUIDE.md → Vercel section
 * - Railway: See AI_ASSISTANT_GUIDE.md → Railway section
 * - AWS Lambda: See AI_ASSISTANT_GUIDE.md → AWS Lambda section
 * - Docker: See DEPLOYMENT_GUIDE.md → Docker section
 */

// ============================================================================
// IMPORTS
// ============================================================================
// AI HINT: These are the capsules used in this flow
// Each capsule is a self-contained service with execute() method

import { createAuthService } from '@capsulas/capsules/auth';
import { createDatabaseService } from '@capsulas/capsules/database';
// ... more imports based on capsules used

// ============================================================================
// ENVIRONMENT CONFIGURATION
// ============================================================================
// AI HINT: All secrets and config come from environment variables
// Never hardcode secrets in this file
// See .env.example for required variables

interface Config {
  database: {
    url: string;
    // AI HINT: Supports PostgreSQL, MySQL, MongoDB
    // Format: postgresql://user:pass@host:5432/db
  };
  auth: {
    jwtSecret: string;
    // AI HINT: Minimum 32 characters for security
    // Generate with: openssl rand -base64 32
  };
  ai?: {
    apiKey: string;
    model: string;
    // AI HINT: Supports OpenAI (gpt-4) and Anthropic (claude-3)
  };
  // ... more config based on capsules
}

const config: Config = {
  database: {
    url: process.env.DATABASE_URL || '',
  },
  auth: {
    jwtSecret: process.env.JWT_SECRET || '',
  },
  ai: {
    apiKey: process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY || '',
    model: process.env.AI_MODEL || 'gpt-4',
  },
};

// Validate required environment variables
// AI HINT: Fails fast if misconfigured - helps catch issues early
const requiredEnvVars = ['DATABASE_URL', 'JWT_SECRET'];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

// ============================================================================
// SERVICE INITIALIZATION
// ============================================================================
// AI HINT: Services are initialized once, reused for all executions
// This is the "dependency injection" pattern
// Services are stateless - safe for concurrent requests

const authService = createAuthService({
  secret: config.auth.jwtSecret,
  // AI HINT: Used for JWT token generation and validation
});

const databaseService = createDatabaseService({
  url: config.database.url,
  // AI HINT: Connection pooling is automatic
  // Default pool size: 10 connections
});

// ... more service initializations

// ============================================================================
// MAIN FLOW EXECUTION
// ============================================================================
// AI HINT: This is the main logic - nodes execute in dependency order
// Each step is numbered and commented for clarity
// Data flows from result_node_X to input_node_Y

/**
 * Execute the complete flow
 *
 * AI DEPLOYMENT HINTS:
 * - Vercel: Wrap in Next.js API handler
 * - Railway: Wrap in Express endpoint
 * - AWS Lambda: Wrap in Lambda handler
 * - Direct: Call from server.ts
 *
 * @returns Flow execution result
 */
export async function executeFlow() {
  try {
    // ==========================================================================
    // STEP 1: Authentication
    // ==========================================================================
    // AI HINT: Node ID: node-1
    // Capsule: JWT Auth
    // Purpose: Validate user credentials and generate token
    // Inputs: None (entry point)
    // Outputs: { token: string, user: User }

    console.log('[STEP 1] Starting: Authentication');

    const result_node_1 = await authService.login({
      email: 'user@example.com',  // TODO: Replace with actual input
      password: 'password',        // TODO: Replace with actual input
    });

    console.log('[STEP 1] Complete:', {
      userId: result_node_1?.user?.id,
      tokenGenerated: !!result_node_1?.token,
    });

    // ==========================================================================
    // STEP 2: Database Query
    // ==========================================================================
    // AI HINT: Node ID: node-2
    // Capsule: Database
    // Purpose: Fetch user profile from database
    // Inputs: result_node_1.user (connected from Step 1)
    // Outputs: { rows: any[], count: number }

    console.log('[STEP 2] Starting: Database Query');

    // Data flowing from previous step
    // AI HINT: This pattern appears for ALL connected nodes
    const input_node_2 = {
      userId: result_node_1?.user?.id,  // From Step 1 output
    };

    const result_node_2 = await databaseService.query({
      table: 'users',
      where: { id: input_node_2.userId },
    });

    console.log('[STEP 2] Complete:', {
      rowsFound: result_node_2?.count,
    });

    // ==========================================================================
    // STEP 3: AI Processing (if applicable)
    // ==========================================================================
    // AI HINT: Node ID: node-3
    // Capsule: AI Chat
    // Purpose: Generate personalized message
    // Inputs: result_node_2.rows[0] (user profile from Step 2)
    // Outputs: { content: string, model: string }

    console.log('[STEP 3] Starting: AI Processing');

    const input_node_3 = {
      userProfile: result_node_2?.rows?.[0],
    };

    const result_node_3 = await aiService?.chat({
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant.',
        },
        {
          role: 'user',
          content: `Generate a welcome message for ${input_node_3.userProfile?.name}`,
        },
      ],
      model: config.ai.model,
    });

    console.log('[STEP 3] Complete:', {
      responseLength: result_node_3?.content?.length,
      model: result_node_3?.model,
    });

    // ==========================================================================
    // RETURN RESULTS
    // ==========================================================================
    // AI HINT: Return the final output
    // Structure depends on your application needs

    return {
      success: true,
      data: {
        user: result_node_1?.user,
        profile: result_node_2?.rows?.[0],
        message: result_node_3?.content,
      },
      metadata: {
        executedSteps: 3,
        timestamp: new Date().toISOString(),
      },
    };

  } catch (error) {
    // ==========================================================================
    // ERROR HANDLING
    // ==========================================================================
    // AI HINT: Errors are logged and re-thrown
    // For production, consider:
    // - Error monitoring (Sentry, Rollbar)
    // - Graceful degradation
    // - Retry logic for transient failures

    console.error('Flow execution failed:', error);

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      metadata: {
        timestamp: new Date().toISOString(),
      },
    };
  }
}

// ============================================================================
// DIRECT EXECUTION (for testing)
// ============================================================================
// AI HINT: Uncomment this block to run directly with: node dist/generated-app.js
// For production, use a proper server (Express, Next.js, Lambda, etc.)

/*
if (require.main === module) {
  executeFlow()
    .then(result => {
      console.log('\n=== Flow Execution Result ===');
      console.log(JSON.stringify(result, null, 2));
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('\n=== Flow Execution Error ===');
      console.error(error);
      process.exit(1);
    });
}
*/

// ============================================================================
// PLATFORM-SPECIFIC WRAPPERS
// ============================================================================
// AI HINT: Uncomment the relevant section for your deployment platform

// --- VERCEL (Next.js API Route) ---
/*
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const result = await executeFlow();
  const statusCode = result.success ? 200 : 500;

  res.status(statusCode).json(result);
}
*/

// --- EXPRESS (Railway, Heroku, Self-hosted) ---
/*
import express from 'express';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.post('/api/flow', async (req, res) => {
  const result = await executeFlow();
  const statusCode = result.success ? 200 : 500;

  res.status(statusCode).json(result);
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
*/

// --- AWS LAMBDA ---
/*
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const result = await executeFlow();

  return {
    statusCode: result.success ? 200 : 500,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
    },
    body: JSON.stringify(result),
  };
};
*/

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================
// AI HINT: These types match the capsule outputs
// Use these for type safety when modifying code

interface User {
  id: string;
  email: string;
  name?: string;
  createdAt: string;
}

interface AuthResult {
  token: string;
  user: User;
  expiresAt: string;
}

interface DatabaseResult<T = any> {
  rows: T[];
  count: number;
}

interface AIResponse {
  content: string;
  model: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

// ============================================================================
// UTILITIES
// ============================================================================
// AI HINT: Helper functions you might need

/**
 * Retry a function with exponential backoff
 * Useful for API calls that might fail temporarily
 */
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;

      const delay = baseDelay * Math.pow(2, attempt);
      console.log(`Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`);

      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw new Error('Max retries exceeded');
}

/**
 * Validate required fields in an object
 * Useful for input validation
 */
function validateRequired<T extends object>(
  obj: T,
  requiredFields: (keyof T)[]
): void {
  const missing = requiredFields.filter(field => !obj[field]);

  if (missing.length > 0) {
    throw new Error(`Missing required fields: ${missing.join(', ')}`);
  }
}

// ============================================================================
// METADATA FOR AI ASSISTANTS
// ============================================================================

/**
 * Flow metadata for AI analysis
 * This helps AI assistants understand the flow structure
 */
export const FLOW_METADATA = {
  version: '0.1.0',
  generated: '2025-01-XX',
  capsules: [
    {
      id: 'node-1',
      type: 'auth-jwt',
      name: 'Authentication',
      envVars: ['JWT_SECRET'],
    },
    {
      id: 'node-2',
      type: 'database',
      name: 'Database Query',
      envVars: ['DATABASE_URL'],
    },
    {
      id: 'node-3',
      type: 'ai-chat',
      name: 'AI Processing',
      envVars: ['OPENAI_API_KEY', 'AI_MODEL'],
    },
  ],
  connections: [
    { from: 'node-1', fromPort: 'user', to: 'node-2', toPort: 'userId' },
    { from: 'node-2', fromPort: 'rows', to: 'node-3', toPort: 'userProfile' },
  ],
  requiredEnvVars: ['DATABASE_URL', 'JWT_SECRET', 'OPENAI_API_KEY'],
  optionalEnvVars: ['AI_MODEL', 'PORT'],
  platforms: {
    vercel: 'Supported - Uncomment Vercel wrapper',
    railway: 'Supported - Uncomment Express wrapper',
    awsLambda: 'Supported - Uncomment Lambda wrapper',
    docker: 'Supported - Use Express wrapper',
    replit: 'Supported - Use Express wrapper',
  },
};

// ============================================================================
// END OF GENERATED CODE
// ============================================================================

/**
 * NEXT STEPS FOR AI ASSISTANTS:
 *
 * 1. ASK THE USER:
 *    - "Where do you want to deploy?" (Vercel, Railway, AWS, etc.)
 *    - "Do you have the required environment variables?"
 *
 * 2. BASED ON PLATFORM:
 *    - Uncomment the relevant wrapper code
 *    - Create platform-specific files (vercel.json, Dockerfile, etc.)
 *    - Provide deployment commands
 *
 * 3. VALIDATION:
 *    - Check all envVars from FLOW_METADATA are set
 *    - Test locally first: npm run build && node dist/generated-app.js
 *    - Verify dependencies in package.json
 *
 * 4. PRODUCTION IMPROVEMENTS (suggest to user):
 *    - Add error monitoring (Sentry)
 *    - Add logging (Winston, Pino)
 *    - Add rate limiting
 *    - Add input validation
 *    - Add tests
 *    - Add health check endpoint
 *
 * 5. REFERENCE DOCS:
 *    - AI_ASSISTANT_GUIDE.md for deployment patterns
 *    - DEPLOYMENT_GUIDE.md for detailed platform instructions
 *    - FAQ.md for common issues
 */
```

## Key Features of This Template

### 1. Clear Section Markers
Every section is marked with `====` for easy navigation

### 2. AI Hints Throughout
Every important section has `// AI HINT:` comments explaining:
- What it does
- Why it's there
- How to modify it
- Common patterns

### 3. Metadata Export
The `FLOW_METADATA` object provides machine-readable structure information

### 4. Platform-Ready
Commented wrappers for all major platforms - just uncomment

### 5. Error Handling
Built-in try/catch with informative error messages

### 6. Environment Validation
Fails fast if configuration is wrong

### 7. Logging
Console logs at each step for debugging

### 8. Type Safety
Full TypeScript types for all data structures

### 9. Utilities Included
Common helpers (retry, validation) ready to use

### 10. Next Steps Guide
Clear instructions for AI assistants at the end

## Usage by AI Assistants

When an AI assistant sees this code:

1. **Read FLOW_METADATA first** - understand the structure
2. **Check platform** - ask user where to deploy
3. **Uncomment wrapper** - for chosen platform
4. **Validate env vars** - from requiredEnvVars list
5. **Provide commands** - based on platform
6. **Suggest improvements** - from "Next Steps" section

This template makes it easy for ANY AI to understand and help deploy Capsulas code.
